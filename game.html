<!DOCTYPE html>
<html lang="vi">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Forsaken - Gameplay (Walls Fixed)</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
      color: white;
      font-family: monospace;
    }
    #ui {
      position: absolute;
      top: 10px;
      left: 10px;
      font-size: 18px;
      background: rgba(0,0,0,0.5);
      padding: 6px 10px;
      border-radius: 8px;
    }
    canvas { display: block; }
  </style>
</head>
<body>
  <div id="ui">
    <div id="timer">⏱ 3:50</div>
  </div>
  <canvas id="game"></canvas>

  <script>
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    // --- RANDOM WALLS ---
    const walls = [];
    const wallCount = Math.floor(Math.random() * 5) + 5; // 5–9 walls
    for (let i = 0; i < wallCount; i++) {
      const w = 80 + Math.random() * 40;
      const h = 15;
      walls.push({
        x: Math.random() * (canvas.width - w),
        y: Math.random() * (canvas.height - h),
        w, h,
        color: "#666"
      });
    }

    // --- COLLISION HELPERS ---
    function collideCircleRect(c, r) {
      const closestX = Math.max(r.x, Math.min(c.x, r.x + r.w));
      const closestY = Math.max(r.y, Math.min(c.y, r.y + r.h));
      const dx = c.x - closestX;
      const dy = c.y - closestY;
      return (dx * dx + dy * dy) < (c.radius * c.radius);
    }

    // --- SAFE SPAWN ---
    function spawnSafe(entity, radius) {
      let tries = 0;
      do {
        entity.x = Math.random() * canvas.width;
        entity.y = Math.random() * canvas.height;
        let bad = false;
        for (const w of walls) {
          if (collideCircleRect({x: entity.x, y: entity.y, radius}, w)) {
            bad = true;
            break;
          }
        }
        if (!bad) break;
        tries++;
      } while (tries < 50);
    }

    // --- PLAYER ---
    const player = {
      x: 0, y: 0,
      color: "deepskyblue",
      speed: 0.25,
      radius: 15,
    };
    spawnSafe(player, player.radius);

    // --- MOBS ---
    const mobs = [];
    const numMobs = 8;
    const killerIndex = Math.floor(Math.random() * numMobs);
    for (let i = 0; i < numMobs; i++) {
      const mob = {
        x: 0, y: 0,
        color: i === killerIndex ? "red" : "lime",
        speed: i === killerIndex ? 0.22 : 0.24,
        radius: 14,
        target: { x: Math.random() * canvas.width, y: Math.random() * canvas.height }
      };
      spawnSafe(mob, mob.radius);
      mobs.push(mob);
    }

    // --- INPUT ---
    const keys = {};
    document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
    document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);

    // --- TIMER ---
    let totalTime = 230;
    const timerEl = document.getElementById("timer");
    function updateTimer(delta) {
      totalTime -= delta / 1000;
      if (totalTime < 0) totalTime = 0;
      const minutes = Math.floor(totalTime / 60);
      const seconds = Math.floor(totalTime % 60).toString().padStart(2, "0");
      timerEl.textContent = `⏱ ${minutes}:${seconds}`;
    }

    // --- COLLISION RESOLVE ---
    function resolveCollision(c, r) {
      const closestX = Math.max(r.x, Math.min(c.x, r.x + r.w));
      const closestY = Math.max(r.y, Math.min(c.y, r.y + r.h));
      const dx = c.x - closestX;
      const dy = c.y - closestY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist === 0) return;
      const overlap = c.radius - dist;
      if (overlap > 0) {
        c.x += (dx / dist) * overlap;
        c.y += (dy / dist) * overlap;
      }
    }

    // --- LOOP ---
    let lastTime = 0;
    function update(time) {
      const delta = time - lastTime;
      lastTime = time;
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // Player movement
      let dx = 0, dy = 0;
      if (keys["w"]) dy -= 1;
      if (keys["s"]) dy += 1;
      if (keys["a"]) dx -= 1;
      if (keys["d"]) dx += 1;
      const len = Math.hypot(dx, dy);
      if (len > 0) {
        dx /= len; dy /= len;
        player.x += dx * player.speed * delta;
        player.y += dy * player.speed * delta;
      }

      // Mobs movement
      for (const mob of mobs) {
        const dx = mob.target.x - mob.x;
        const dy = mob.target.y - mob.y;
        const dist = Math.hypot(dx, dy);
        if (dist > 2) {
          mob.x += (dx / dist) * mob.speed * delta;
          mob.y += (dy / dist) * mob.speed * delta;
        } else {
          mob.target = { x: Math.random() * canvas.width, y: Math.random() * canvas.height };
        }
      }

      // --- Collision with walls ---
      for (const wall of walls) {
        if (collideCircleRect(player, wall)) resolveCollision(player, wall);
        for (const mob of mobs) {
          if (collideCircleRect(mob, wall)) resolveCollision(mob, wall);
        }
      }

      // Draw walls
      for (const wall of walls) {
        ctx.fillStyle = wall.color;
        ctx.fillRect(wall.x, wall.y, wall.w, wall.h);
      }

      // Draw mobs
      for (const mob of mobs) {
        ctx.beginPath();
        ctx.arc(mob.x, mob.y, mob.radius, 0, Math.PI * 2);
        ctx.fillStyle = mob.color;
        ctx.fill();
      }

      // Draw player
      ctx.beginPath();
      ctx.arc(player.x, player.y, player.radius, 0, Math.PI * 2);
      ctx.fillStyle = player.color;
      ctx.fill();

      updateTimer(delta);
      requestAnimationFrame(update);
    }

    requestAnimationFrame(update);
    window.addEventListener("resize", () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });
  </script>
</body>
</html>
